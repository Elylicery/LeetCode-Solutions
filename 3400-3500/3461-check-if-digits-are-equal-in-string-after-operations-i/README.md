# 3461. 判断操作后字符串中的数字是否相等 I

用 **“原地覆盖数组”** 实现字符串压缩的逻辑 —— 通过两层循环，外层控制 “压缩轮次”，内层控制 “每轮压缩的计算与覆盖”，最终保留前两位判断是否相等。

**代码核心逻辑**
代码将输入字符串转成数组 arr，通过两层循环模拟 “重复压缩直到剩 2 位”：
* 外层循环（i 从 1 到 n-2）：控制 “压缩轮次”，每轮压缩后，数组的 “效长度” 减少 1（i 每增 1，有效长度 = 初始长度 - i）；
* 内层循环（j 从 0 到 n-1-i）：在当前 “有效长度” 内，计算 arr[j] + arr[j+1] %10，并原地覆盖 arr [j]（因为下一轮只需用前 “有效长度 - 1” 位）；
* 最终判断：压缩到只剩 2 位（即 arr[0] 和 arr[1]），返回两者是否相等。


```ts
/**
 * 压缩模拟
 * 时间复杂度为 O(n2),空间复杂度为 O(1)
 */
function hasSameDigits(s: string): boolean {
    // 1. 字符串转数组，用于原地覆盖（优化空间占用）
    let arr: string[] = s.split('');
    // 2. 初始长度n，外层循环控制压缩轮次（需压缩n-2轮，最终剩2位）
    const n = arr.length;

    // 外层循环：i从1到n-2，每轮压缩后有效长度减少1
    for (let i = 1; i <= n - 2; i++) {
        // 内层循环：j的范围随i变化，仅处理当前有效长度内的元素
        // 有效长度 = n - i，因此j最大为 (n - i) - 1 = n - i - 1
        for (let j = 0; j <= n - 1 - i; j++) {
            // 计算当前位置与下一位的和模10，原地覆盖当前位置
            const sum = parseInt(arr[j]) + parseInt(arr[j + 1]);
            arr[j] = String(sum % 10);
        }
    }

    // 3. 最终判断前两位是否相等（压缩后仅剩前两位有效）
    return arr[0] === arr[1];
}

// 示例测试
console.log(hasSameDigits("3902"));  // 输出：true（对应示例1）
console.log(hasSameDigits("34789")); // 输出：false（对应示例2）

```